from genie.testbed import load
from pyats.topology import loader
from pyats import aetest
import re, logging
from acl_lib import NetconfCommonFunctions

logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

class CommonSetup(aetest.CommonSetup):
    @aetest.subsection
    def connect_to_devices(self, testbed):
        global device
        device = testbed.devices['n9k1']
        device.connect(alias='nc', via='netconf')
        assert device.nc.connected, "Device connection failed"

class ConfigureACLOnDevice(aetest.Testcase):
    acl_name = 'aclnqt'

    @aetest.test
    def configure_acl(self):
        try:
            reply_command = NetconfCommonFunctions.configure_acl_on_device(device)
            logging.info("Configuration Reply: %s", reply_command)
        except Exception as e:
            self.failed(f"Failed to send configuration command: {e}")

    @aetest.test
    def verify_acl_and_ping(self):
        destination_ip = "192.168.10.1"  # Use the appropriate destination IP address for your setup
        verification_request = f"""
        <?xml version="1.0" encoding="UTF-8"?>
        <nf:rpc message-id="111" xmlns:nf="urn:ietf:params:xml:ns:netconf:base:1.0" xmlns:nxos="http://www.cisco.com/nxos:1.0">
            <nxos:exec-command>
                <nxos:cmd>show ip access-lists {self.acl_name}</nxos:cmd>
            </nxos:exec-command>
        </nf:rpc>
        """
        try:
            verification_reply = device.nc.request(verification_request)
            acl_output = str(verification_reply)
            rule = r"<mod:seqno>10</mod:seqno>\s*<mod:permitdeny>[a-z]{6}</mod:permitdeny>\s*<mod:ip>[a-z]{2}</mod:ip>\s*<mod:src_ip_prefix>10\.10\.10\.1/24</mod:src_ip_prefix>\s*<mod:dest_any>[a-z]{3}</mod:dest_any>"

            match = re.search(rule, acl_output)
            if match:
                logging.info("The ACL rule is verified successfully.")
                logging.info("Matched Line: %s", match.group(0))
            else:
                self.failed(f"ACL rule matching '{rule}' not found in the device configuration")
            
            # Ping the destination IP
            ping_reply = NetconfCommonFunctions.ping_device(device, destination_ip)
            logging.info("Ping Reply: %s", ping_reply)

            # Validate ping results
            ping_result = NetconfCommonFunctions.validate_ping(ping_reply)
            sent_pkt = int(ping_result.get('sent_pkt', 0))
            receive_pkt = int(ping_result.get('receive_pkt', 0))
            pkt_loss = ping_result.get('pkt_loss', "0%")

            if sent_pkt == receive_pkt and pkt_loss == "0%":
                self.passed("Ping successful with no packet loss")
            else:
                self.failed("Ping failed with packet loss: {}".format(pkt_loss))

        except Exception as e:
            self.failed(f"Failed to send verification command: {e}")

    @aetest.test
    def unconfigure_acl(self):
        try:
            reply_command = NetconfCommonFunctions.unconfigure_acl_on_device(device)
            logging.info("Unconfiguration Reply: %s", reply_command)
        except Exception as e:
            self.failed(f"Failed to send unconfiguration command: {e}")

class ConfigureACLOnInterface(aetest.Testcase):
    acl_name = 'aclnqt'

    @aetest.test
    def configure_acl(self):
        try:
            reply_command = NetconfCommonFunctions.configure_acl_on_interface(device)
            logging.info("Configuration Reply: %s", reply_command)
        except Exception as e:
            self.failed(f"Failed to send configuration command: {e}")

    @aetest.test
    def verify_acl_and_ping(self):
        destination_ip = "192.168.10.1"  # Use the appropriate destination IP address for your setup
        verification_request = f"""
        <?xml version="1.0" encoding="UTF-8"?>
        <nf:rpc message-id="112" xmlns:nf="urn:ietf:params:xml:ns:netconf:base:1.0" xmlns:nxos="http://www.cisco.com/nxos:1.0">
            <nxos:exec-command>
                <nxos:cmd>show running-config interface Ethernet1/5</nxos:cmd>
            </nxos:exec-command>
        </nf:rpc>
        """
        try:
            verification_reply = device.nc.request(verification_request)
            acl_output = str(verification_reply)
            rule = r"ip access-group aclnqt in"
            match = re.search(rule, acl_output)
            if match:
                logging.info("The ACL application to interface is verified successfully.")
                logging.info("Matched Line: %s", match.group(0))
            else:
                self.failed(f"ACL application to interface matching '{rule}' not found in the device configuration")
            
            # Ping the destination IP
            ping_reply = NetconfCommonFunctions.ping_device(device, destination_ip)
            logging.info("Ping Reply: %s", ping_reply)

            # Validate ping results
            ping_result = NetconfCommonFunctions.validate_ping(ping_reply)
            sent_pkt = int(ping_result.get('sent_pkt', 0))
            receive_pkt = int(ping_result.get('receive_pkt', 0))
            pkt_loss = ping_result.get('pkt_loss', "0%")

            if sent_pkt == receive_pkt and pkt_loss == "0%":
                self.passed("Ping successful with no packet loss")
            else:
                self.failed("Ping failed with packet loss: {}".format(pkt_loss))

        except Exception as e:
            self.failed(f"Failed to send verification command: {e}")

    @aetest.test
    def unconfigure_acl(self):
        try:
            reply_command = NetconfCommonFunctions.unconfigure_acl_on_interface(device)
            logging.info("Unconfiguration Reply: %s", reply_command)
        except Exception as e:
            self.failed(f"Failed to send unconfiguration command: {e}")

class CommonCleanup(aetest.CommonCleanup):
    @aetest.subsection
    def disconnect(self):
        device.nc.disconnect()
        assert not device.nc.connected, "Device disconnection failed"

if __name__ == '__main__':
    import argparse
    from pyats import aetest
    from genie.testbed import load

    parser = argparse.ArgumentParser()
    parser.add_argument('--testbed', dest='testbed', type=loader.load)
    args, unknown = parser.parse_known_args()

    aetest.main(**vars(args))
